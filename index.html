<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random P2P Chat</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chat-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #333;
            font-size: 2.5em;
            font-weight: 600;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .status {
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 20px;
            font-weight: 500;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
        }

        .status.disconnected {
            background: #fee;
            color: #c53030;
            border: 2px solid #feb2b2;
        }

        .status.connecting {
            background: #fffaf0;
            color: #d69e2e;
            border: 2px solid #fbd38d;
        }

        .status.connecting::after {
            content: '';
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            border: 2px solid #d69e2e;
            border-top: 2px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: translateY(-50%) rotate(0deg); }
            100% { transform: translateY(-50%) rotate(360deg); }
        }

        .status.connected {
            background: #f0fff4;
            color: #38a169;
            border: 2px solid #9ae6b4;
        }

        .status.waiting {
            background: #ebf4ff;
            color: #3182ce;
            border: 2px solid #90cdf4;
        }

        .chat-messages {
            height: 300px;
            overflow-y: auto;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            background: #f8fafc;
            scroll-behavior: smooth;
        }

        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 10px;
        }

        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        .message {
            margin-bottom: 15px;
            padding: 12px 16px;
            border-radius: 18px;
            max-width: 80%;
            word-wrap: break-word;
            animation: messageSlide 0.3s ease-out;
            position: relative;
        }

        @keyframes messageSlide {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.sent {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            margin-left: auto;
            text-align: right;
        }

        .message.received {
            background: #e2e8f0;
            color: #2d3748;
        }

        .message.system {
            background: #fed7d7;
            color: #c53030;
            text-align: center;
            margin: 0 auto;
            font-style: italic;
            max-width: 90%;
        }

        .typing-indicator {
            display: none;
            padding: 10px 16px;
            background: #e2e8f0;
            border-radius: 18px;
            max-width: 80px;
            margin-bottom: 10px;
        }

        .typing-indicator.show {
            display: block;
            animation: messageSlide 0.3s ease-out;
        }

        .typing-dots {
            display: flex;
            gap: 4px;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            background: #718096;
            border-radius: 50%;
            animation: typingPulse 1.4s ease-in-out infinite both;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typingPulse {
            0%, 80%, 100% {
                transform: scale(0.8);
                opacity: 0.5;
            }
            40% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .input-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            position: relative;
        }

        .message-input {
            flex: 1;
            padding: 15px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 16px;
            transition: all 0.3s ease;
            background: white;
            resize: none;
            min-height: 50px;
            max-height: 120px;
        }

        .message-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .char-counter {
            position: absolute;
            bottom: -20px;
            right: 10px;
            font-size: 12px;
            color: #666;
        }

        .send-btn, .connect-btn, .disconnect-btn, .skip-btn {
            padding: 15px 25px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .send-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .send-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .connect-btn {
            background: linear-gradient(135deg, #48bb78, #38a169);
            color: white;
            width: 100%;
            margin-bottom: 10px;
        }

        .connect-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(72, 187, 120, 0.4);
        }

        .disconnect-btn, .skip-btn {
            background: linear-gradient(135deg, #f56565, #e53e3e);
            color: white;
            width: 48%;
        }

        .skip-btn {
            background: linear-gradient(135deg, #ed8936, #dd6b20);
        }

        .disconnect-btn:hover, .skip-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(245, 101, 101, 0.4);
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-buttons {
            display: flex;
            gap: 10px;
            justify-content: space-between;
        }

        .user-count {
            text-align: center;
            color: #666;
            font-size: 14px;
            margin-top: 10px;
        }

        .connection-info {
            font-size: 12px;
            color: #666;
            text-align: center;
            margin-top: 5px;
        }

        .demo-badge {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: bold;
            display: inline-block;
            margin-left: 8px;
        }

        @media (max-width: 480px) {
            .chat-container {
                padding: 20px;
                margin: 20px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .input-container {
                flex-direction: column;
            }

            .control-buttons {
                flex-direction: column;
            }

            .disconnect-btn, .skip-btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="header">
            <h1>Random P2P Chat</h1>
            <p>Connect with strangers instantly</p>
        </div>

        <div id="status" class="status disconnected">
            Disconnected - Click "Find Random Chat" to start
        </div>

        <div id="chatMessages" class="chat-messages">
            <div id="typingIndicator" class="typing-indicator">
                <div class="typing-dots">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                </div>
            </div>
        </div>

        <div class="input-container">
            <textarea 
                id="messageInput" 
                class="message-input" 
                placeholder="Type your message..."
                disabled
                rows="1"
                maxlength="500"
            ></textarea>
            <div class="char-counter" id="charCounter">0/500</div>
            <button id="sendBtn" class="send-btn" disabled>Send</button>
        </div>

        <div class="controls">
            <button id="connectBtn" class="connect-btn">Find Random Chat</button>
            <div class="control-buttons" style="display: none;" id="controlButtons">
                <button id="disconnectBtn" class="disconnect-btn">Disconnect</button>
                <button id="skipBtn" class="skip-btn">Skip User</button>
            </div>
        </div>

        <div id="userCount" class="user-count">Users online: 0</div>
        <div id="connectionInfo" class="connection-info"></div>
    </div>

    <script>
        class P2PChat {
            constructor() {
                this.ws = null;
                this.peerConnection = null;
                this.dataChannel = null;
                this.isConnected = false;
                this.isConnecting = false;
                this.userId = this.generateUserId();
                this.partnerId = null;
                this.isInitiator = false;
                this.messageQueue = [];
                this.typingTimer = null;
                this.lastActivity = Date.now();
                
                this.initializeElements();
                this.bindEvents();
                
                // WebRTC configuration with multiple STUN servers
                this.rtcConfiguration = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun.stunprotocol.org:3478' },
                        { urls: 'stun:stun2.l.google.com:19302' },
                        { urls: 'stun:stun3.l.google.com:19302' },
                        { urls: 'stun:stun4.l.google.com:19302' }
                    ]
                };

                // Try to connect to signaling server
                this.connectToSignalingServer();
            }

            generateUserId() {
                return 'user_' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
            }

            initializeElements() {
                this.statusEl = document.getElementById('status');
                this.messagesEl = document.getElementById('chatMessages');
                this.messageInput = document.getElementById('messageInput');
                this.sendBtn = document.getElementById('sendBtn');
                this.connectBtn = document.getElementById('connectBtn');
                this.disconnectBtn = document.getElementById('disconnectBtn');
                this.skipBtn = document.getElementById('skipBtn');
                this.userCountEl = document.getElementById('userCount');
                this.connectionInfoEl = document.getElementById('connectionInfo');
                this.controlButtonsEl = document.getElementById('controlButtons');
                this.typingIndicator = document.getElementById('typingIndicator');
                this.charCounter = document.getElementById('charCounter');
            }

            bindEvents() {
                this.connectBtn.addEventListener('click', () => this.findRandomChat());
                this.disconnectBtn.addEventListener('click', () => this.disconnect());
                this.skipBtn.addEventListener('click', () => this.skipUser());
                this.sendBtn.addEventListener('click', () => this.sendMessage());

                // Enhanced input handling
                this.messageInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });

                // Character counter
                this.messageInput.addEventListener('input', (e) => {
                    const length = e.target.value.length;
                    this.charCounter.textContent = `${length}/500`;
                    this.charCounter.style.color = length > 450 ? '#e53e3e' : '#666';
                    
                    // Auto-resize textarea
                    e.target.style.height = 'auto';
                    e.target.style.height = Math.min(e.target.scrollHeight, 120) + 'px';
                    
                    // Simulate typing indicator in demo mode
                    if (this.demoMode && this.isConnected && length > 0) {
                        this.simulatePartnerTyping();
                    }
                });

                // Handle page visibility change
                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden && !this.ws) {
                        this.connectToSignalingServer();
                    }
                });

                // Activity tracking
                ['click', 'keypress', 'touchstart'].forEach(event => {
                    document.addEventListener(event, () => {
                        this.lastActivity = Date.now();
                    });
                });
            }

            updateStatus(message, type = 'disconnected') {
                this.statusEl.textContent = message;
                this.statusEl.className = `status ${type}`;
                
                // Add demo badge if in demo mode
                if (this.demoMode && type === 'connected') {
                    const badge = document.createElement('span');
                    badge.className = 'demo-badge';
                    badge.textContent = 'DEMO';
                    this.statusEl.appendChild(badge);
                }
            }

            addMessage(content, type = 'system', timestamp = true) {
                const messageEl = document.createElement('div');
                messageEl.className = `message ${type}`;
                
                if (timestamp && (type === 'sent' || type === 'received')) {
                    const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    messageEl.innerHTML = `<div>${this.escapeHtml(content)}</div><small style="opacity: 0.7; font-size: 11px;">${time}</small>`;
                } else {
                    messageEl.textContent = content;
                }
                
                // Insert before typing indicator
                this.messagesEl.insertBefore(messageEl, this.typingIndicator);
                this.messagesEl.scrollTop = this.messagesEl.scrollHeight;
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            showTypingIndicator() {
                this.typingIndicator.classList.add('show');
                this.messagesEl.scrollTop = this.messagesEl.scrollHeight;
            }

            hideTypingIndicator() {
                this.typingIndicator.classList.remove('show');
            }

            simulatePartnerTyping() {
                if (!this.isConnected || !this.demoMode) return;
                
                clearTimeout(this.typingTimer);
                this.showTypingIndicator();
                
                this.typingTimer = setTimeout(() => {
                    this.hideTypingIndicator();
                }, 2000 + Math.random() * 1000);
            }

            async connectToSignalingServer() {
                try {
                    const serverUrl = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' 
                        ? 'ws://localhost:3001' 
                        : `wss://${window.location.host}/ws`;
                    
                    console.log('Attempting to connect to:', serverUrl);
                    this.ws = new WebSocket(serverUrl);
                    
                    this.ws.onopen = () => {
                        console.log('Connected to signaling server');
                        this.connectionInfoEl.textContent = 'Connected to server';
                        
                        // Request user count
                        this.ws.send(JSON.stringify({ type: 'get-user-count' }));
                    };

                    this.ws.onmessage = async (event) => {
                        const data = JSON.parse(event.data);
                        console.log('Received message:', data);
                        await this.handleSignalingMessage(data);
                    };

                    this.ws.onclose = () => {
                        console.log('Disconnected from signaling server');
                        this.connectionInfoEl.textContent = 'Disconnected from server - retrying...';
                        if (!this.demoMode) {
                            setTimeout(() => this.connectToSignalingServer(), 3000);
                        }
                    };

                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.connectionInfoEl.textContent = 'Server connection failed';
                        if (!this.demoMode) {
                            this.startOfflineMode();
                        }
                    };

                } catch (error) {
                    console.error('Failed to connect to signaling server:', error);
                    this.startOfflineMode();
                }
            }

            startOfflineMode() {
                console.log('ðŸŽ­ Starting enhanced demo mode');
                this.demoMode = true;
                this.addMessage('Demo Mode: Server not available - simulating P2P chat experience', 'system');
                this.addMessage('Click "Find Random Chat" to experience the interface! ðŸš€', 'system');
                this.connectionInfoEl.textContent = 'Demo Mode - No server required';
                this.simulateUserCount();
            }

            simulateUserCount() {
                let userCount = Math.floor(Math.random() * 80) + 40; // 40-120 users
                this.userCountEl.textContent = `Users online: ${userCount}`;
                
                const updateCount = () => {
                    const change = Math.floor(Math.random() * 8) - 4; // -4 to +4
                    userCount = Math.max(20, Math.min(userCount + change, 150));
                    this.userCountEl.textContent = `Users online: ${userCount}`;
                };
                
                setInterval(updateCount, 12000); // Update every 12 seconds
            }

            async handleSignalingMessage(data) {
                switch (data.type) {
                    case 'user-count':
                        this.userCountEl.textContent = `Users online: ${data.count}`;
                        break;
                        
                    case 'matched':
                        this.partnerId = data.partnerId;
                        this.isInitiator = data.isInitiator;
                        this.updateStatus('Found a partner! Establishing connection...', 'connecting');
                        await this.createPeerConnection();
                        break;
                        
                    case 'offer':
                        await this.handleOffer(data);
                        break;
                        
                    case 'answer':
                        await this.handleAnswer(data);
                        break;
                        
                    case 'ice-candidate':
                        await this.handleIceCandidate(data);
                        break;
                        
                    case 'partner-disconnected':
                        this.handlePartnerDisconnect();
                        break;

                    case 'waiting':
                        this.updateStatus('Waiting for someone to chat with...', 'waiting');
                        break;
                }
            }

            async findRandomChat() {
                // Handle demo mode
                if (this.demoMode) {
                    this.simulateDemoConnection();
                    return;
                }
                
                const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                
                if (isLocal && (!this.ws || this.ws.readyState !== WebSocket.OPEN)) {
                    this.updateStatus('Connecting to server...', 'connecting');
                    await this.connectToSignalingServer();
                    return;
                }

                this.isConnecting = true;
                this.updateStatus('Looking for someone to chat with...', 'connecting');
                this.connectBtn.style.display = 'none';
                this.controlButtonsEl.style.display = 'flex';
                
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'find-match',
                        userId: this.userId
                    }));
                } else {
                    // Fallback to demo mode if no server connection
                    this.demoMode = true;
                    setTimeout(() => this.simulateDemoConnection(), 1000);
                }
            }

            simulateDemoConnection() {
                console.log('ðŸŽ­ Simulating demo connection');
                
                this.isConnecting = true;
                this.updateStatus('Looking for someone to chat with...', 'connecting');
                this.connectBtn.style.display = 'none';
                this.controlButtonsEl.style.display = 'flex';
                
                // Simulate realistic connection time
                setTimeout(() => {
                    this.partnerId = 'demo_partner_' + Math.random().toString(36).substr(2, 8);
                    this.isConnected = true;
                    this.isConnecting = false;
                    
                    this.updateStatus('Connected! Start chatting', 'connected');
                    this.messageInput.disabled = false;
                    this.sendBtn.disabled = false;
                    this.addMessage('Connected to a simulated chat partner. Try sending a message! ðŸ¤–', 'system');
                    this.messageInput.focus();
                    
                    // Start simulated responses
                    this.simulatePartnerResponses();
                }, 2000 + Math.random() * 3000);
            }

            simulatePartnerResponses() {
                const responses = [
                    "Hello! How are you today? ðŸ‘‹",
                    "Nice to meet you! What's your name?",
                    "This chat app looks really cool!",
                    "That's interesting! Tell me more about that.",
                    "I'm doing great, thanks for asking! ðŸ˜Š",
                    "What's your favorite hobby?",
                    "Where are you from?",
                    "The weather is nice today, isn't it?",
                    "Do you like music? What's your favorite genre?",
                    "I love chatting with new people!",
                    "This is a pretty neat demo! ðŸš€",
                    "What do you think about this app?",
                    "Have you used other chat apps before?",
                    "Technology is amazing these days!",
                    "Hope you're having a great day! â˜€ï¸",
                    "That's so cool! I'd love to hear more.",
                    "Haha, that's funny! ðŸ˜„",
                    "I agree completely!",
                    "What's your favorite movie?",
                    "Do you have any pets?"
                ];

                let responseCount = 0;
                const maxResponses = 12;

                const sendResponse = (immediate = false) => {
                    if (!this.isConnected || responseCount >= maxResponses) return;
                    
                    const delay = immediate ? 1000 + Math.random() * 2000 : 3000 + Math.random() * 7000;
                    
                    // Show typing indicator first
                    setTimeout(() => {
                        if (this.isConnected && responseCount < maxResponses) {
                            this.showTypingIndicator();
                            
                            // Send message after typing delay
                            setTimeout(() => {
                                if (this.isConnected) {
                                    this.hideTypingIndicator();
                                    const response = responses[Math.floor(Math.random() * responses.length)];
                                    this.addMessage(response, 'received');
                                    responseCount++;
                                    
                                    // Sometimes send a follow-up
                                    if (Math.random() < 0.25 && responseCount < maxResponses) {
                                        setTimeout(() => sendResponse(true), 2000 + Math.random() * 3000);
                                    }
                                }
                            }, 1000 + Math.random() * 2000);
                        }
                    }, delay);
                };

                // Send initial greeting
                sendResponse(true);

                // Override sendMessage to trigger responses
                const originalSendMessage = this.sendMessage.bind(this);
                this.sendMessage = function() {
                    const result = originalSendMessage();
                    
                    // 75% chance to respond to user messages
                    if (this.isConnected && Math.random() < 0.75) {
                        sendResponse(true);
                    }
                    
                    return result;
                };
            }

            async createPeerConnection() {
                this.peerConnection = new RTCPeerConnection(this.rtcConfiguration);
                
                // Set up data channel
                if (this.isInitiator) {
                    this.dataChannel = this.peerConnection.createDataChannel('messages', {
                        ordered: true
                    });
                    this.setupDataChannel(this.dataChannel);
                } else {
                    this.peerConnection.ondatachannel = (event) => {
                        this.dataChannel = event.channel;
                        this.setupDataChannel(this.dataChannel);
                    };
                }

                // Handle ICE candidates
                this.peerConnection.onicecandidate = async (event) => {
                    if (event.candidate && this.ws && this.ws.readyState === WebSocket.OPEN) {
                        this.ws.send(JSON.stringify({
                            type: 'ice-candidate',
                            candidate: event.candidate,
                            to: this.partnerId
                        }));
                    }
                };

                // Handle connection state changes
                this.peerConnection.onconnectionstatechange = () => {
                    console.log('Connection state:', this.peerConnection.connectionState);
                    if (this.peerConnection.connectionState === 'failed') {
                        this.addMessage('Connection failed. Please try again.', 'system');
                        this.disconnect();
                    }
                };

                if (this.isInitiator) {
                    const offer = await this.peerConnection.createOffer();
                    await this.peerConnection.setLocalDescription(offer);
                    
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        this.ws.send(JSON.stringify({
                            type: 'offer',
                            offer: offer,
                            to: this.partnerId
                        }));
                    }
                }
            }

            setupDataChannel(channel) {
                channel.onopen = () => {
                    console.log('Data channel opened');
                    this.isConnected = true;
                    this.isConnecting = false;
                    this.updateStatus('Connected! Start chatting.', 'connected');
                    this.messageInput.disabled = false;
                    this.sendBtn.disabled = false;
                    this.addMessage('Connected to a stranger. Say hello! ðŸ‘‹', 'system');
                    this.messageInput.focus();
                    
                    // Send queued messages
                    while (this.messageQueue.length > 0) {
                        const queuedMessage = this.messageQueue.shift();
                        channel.send(queuedMessage);
                    }
                };

                channel.onmessage = (event) => {
                    this.addMessage(event.data, 'received');
                };

                channel.onclose = () => {
                    console.log('Data channel closed');
                    if (this.isConnected) {
                        this.addMessage('Your chat partner disconnected', 'system');
                        this.handlePartnerDisconnect();
                    }
                };

                channel.onerror = (error) => {
                    console.error('Data channel error:', error);
                    this.addMessage('Connection error occurred', 'system');
                };
            }

            async handleOffer(data) {
                await this.peerConnection.setRemoteDescription(data.offer);
                const answer = await this.peerConnection.createAnswer();
                await this.peerConnection.setLocalDescription(answer);
                
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'answer',
                        answer: answer,
                        to: data.from
                    }));
                }
            }

            async handleAnswer(data) {
                await this.peerConnection.setRemoteDescription(data.answer);
            }

            async handleIceCandidate(data) {
                try {
                    await this.peerConnection.addIceCandidate(data.candidate);
                } catch (error) {
                    console.error('Error adding ICE candidate:', error);
                }
            }

            handlePartnerDisconnect() {
                this.isConnected = false;
                this.isConnecting = false;
                this.partnerId = null;
                
                if (this.peerConnection) {
                    this.peerConnection.close();
                    this.peerConnection = null;
                }
                
                if (this.dataChannel) {
                    this.dataChannel.close();
                    this.dataChannel = null;
                }
                
                this.hideTypingIndicator();
                this.updateStatus('Partner disconnected', 'disconnected');
                this.resetUI();
            }

            sendMessage() {
                const message = this.messageInput.value.trim();
                if (!message || message.length > 500) return;

                if (this.isConnected) {
                    if (this.dataChannel && this.dataChannel.readyState === 'open') {
                        this.dataChannel.send(message);
                    }
                    this.addMessage(message, 'sent');
                } else if (this.isConnecting) {
                    // Queue message if still connecting
                    this.messageQueue.push(message);
                    this.addMessage(message, 'sent');
                    this.addMessage('Message queued - connecting...', 'system');
                }
                
                this.messageInput.value = '';
                this.charCounter.textContent = '0/500';
                this.messageInput.style.height = 'auto';
            }

            skipUser() {
                if (this.isConnected || this.isConnecting) {
                    this.addMessage('Looking for a new chat partner...', 'system');
                    this.disconnect();
                    setTimeout(() => {
                        this.findRandomChat();
                    }, 500);
                }
            }

            async disconnect() {
                this.isConnected = false;
                this.isConnecting = false;
                
                if (this.dataChannel) {
                    this.dataChannel.close();
                    this.dataChannel = null;
                }
                
                if (this.peerConnection) {
                    this.peerConnection.close();
                    this.peerConnection = null;
                }
                
                // Notify server of disconnection
                if (this.ws && this.ws.readyState === WebSocket.OPEN && this.partnerId) {
                    this.ws.send(JSON.stringify({
                        type: 'disconnect',
                        partnerId: this.partnerId
                    }));
                }
                
                this.partnerId = null;
                this.hideTypingIndicator();
                clearTimeout(this.typingTimer);
                
                this.updateStatus('Disconnected', 'disconnected');
                this.addMessage('Disconnected from chat', 'system');
                this.resetUI();
            }

            resetUI() {
                this.messageInput.disabled = true;
                this.sendBtn.disabled = true;
                this.connectBtn.style.display = 'block';
                this.controlButtonsEl.style.display = 'none';
                this.messageInput.value = '';
                this.charCounter.textContent = '0/500';
                this.messageInput.style.height = 'auto';
                this.messageQueue = [];
            }
        }

        // Initialize the chat app when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.p2pChat = new P2PChat();
        });

        // Handle page unload
        window.addEventListener('beforeunload', () => {
            if (window.p2pChat) {
                window.p2pChat.disconnect();
            }
        });
    </script>
</body>
</html>
